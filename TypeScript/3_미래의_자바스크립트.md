# 미래의 자바스크립트



## 클래스

### Abstract

- 기본적으로 해당 기능이 직접적으로 실행될 수 없음을 뜻한다.
- 자식 클래스가 그 기능을 제공해야 한다.

```typescript
abstract class FooCommand {}

class BarCommand extends FooCommand {}

const fooCommand: FooCommand = new FooCommand(); // abstract 클래스 인스턴스는 생성할 수 없음.

const barCommand = new BarCommand(); // abstract 클래스를 상속한 클래스의 인스턴스는 생성 가능.

abstract class FooCommand {
  abstract execute(): string;
}

class BarErrorCommand  extends FooCommand {} // 'BarErrorCommand'는 추상(abstract) 멤버인 'execute'를 제공해야 함.

class BarCommand extends FooCommand {
  execute() {
    return `명령 실행함 !`;
  }
}

const barCommand = new BarCommand();

barCommand.execute(); // Command Bar executed 출력
```



### constructor

- 클래스 내에서 구성원에 엑세스 수식어를 접두어로 사용하는 일반적인 패턴으로 클래스에 자동으로 선언되어 생성자에 복사되기 때문에 constructor 에 바로 작성하면 된다.



### Property 초기화

- 생성자 밖에서 프로퍼티를 초기화할 수 있다.( es7에서 지원됨 )



## 화살표 함수

- 화살표 함수를 사용하면 함수 안에 화살표 함수를 선언했을 때 바깥 함수내부의 프로퍼티에 접근할 수 있다.
- 더이상 const _this = this; 를 사용하지 않아도 된다.

**화살표 함수의 필요성**

```typescript
var growOld = person.growOld
growOld()
```

- 위 코드처럼 함수를 직접적으로 호출할 수 있다.

만약 this를 사용하려한다면 화살표 함수를 사용하면 안 된다.

만약 사용해야할 상황이 온다면 아래 코드처럼 화살표 함수가 원래 없던 것 처럼 사용한다.

~~~typescript
let _self = this
something.each(function() {
    console.log(_self) // the lexically scoped value
    console.log(this) // the library passed value
})
~~~

