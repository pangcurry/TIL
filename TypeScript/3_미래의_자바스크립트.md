# 미래의 자바스크립트



## 클래스

### Abstract

- 기본적으로 해당 기능이 직접적으로 실행될 수 없음을 뜻한다.
- 자식 클래스가 그 기능을 제공해야 한다.

```typescript
abstract class FooCommand {}

class BarCommand extends FooCommand {}

const fooCommand: FooCommand = new FooCommand(); // abstract 클래스 인스턴스는 생성할 수 없음.

const barCommand = new BarCommand(); // abstract 클래스를 상속한 클래스의 인스턴스는 생성 가능.

abstract class FooCommand {
  abstract execute(): string;
}

class BarErrorCommand  extends FooCommand {} // 'BarErrorCommand'는 추상(abstract) 멤버인 'execute'를 제공해야 함.

class BarCommand extends FooCommand {
  execute() {
    return `명령 실행함 !`;
  }
}

const barCommand = new BarCommand();

barCommand.execute(); // Command Bar executed 출력
```



### constructor

- 클래스 내에서 구성원에 엑세스 수식어를 접두어로 사용하는 일반적인 패턴으로 클래스에 자동으로 선언되어 생성자에 복사되기 때문에 constructor 에 바로 작성하면 된다.



### Property 초기화

- 생성자 밖에서 프로퍼티를 초기화할 수 있다.( es7에서 지원됨 )



## 화살표 함수

- 화살표 함수를 사용하면 함수 안에 화살표 함수를 선언했을 때 바깥 함수내부의 프로퍼티에 접근할 수 있다.
- 더이상 const _this = this; 를 사용하지 않아도 된다.

**화살표 함수의 필요성**

```typescript
var growOld = person.growOld
growOld()
```

- 위 코드처럼 함수를 직접적으로 호출할 수 있다.

만약 this를 사용하려한다면 화살표 함수를 사용하면 안 된다.

만약 사용해야할 상황이 온다면 아래 코드처럼 화살표 함수가 원래 없던 것 처럼 사용한다.

~~~typescript
let _self = this
something.each(function() {
    console.log(_self) // the lexically scoped value
    console.log(this) // the library passed value
})
~~~



## 나머지 연산자

- `...argumentName` 을 이요해서 여러개의 인자를 배열로 받는다.

~~~typescript
function iTakeItAll(first, second, ...allOthers) {
    console.log(allOthers)
}
iTakeItAll('foo', 'bar') // []
iTakeItAll('foo', 'bar', 'bas', 'qux') // ['bas','qux']
~~~

- 나머지 연산자는 어떠한 형태의 함수에서도 사용 가능하다.
  - `function /. ) => / class member`



## let

- let은 블록 스코프 범위이다.

### Switch

- Case 에서 {}를 감싸서 변수를 재사용할 수 있다.

~~~typescript
switch (name) {
    case 'x': {
        let x = 5
        // ...
        break
    }
    case 'y': {
        let x = 10
        // ...
        break
    }
}
~~~



### Let in closures

```typescript
var funcs = []
// create a bunch of functions
for (var i = 0; i < 3; i++) {
    funcs.push(function() {
        console.log(i)
    })
}
// call them
for (var j = 0; j < 3; j++) {
    funcs[j]()
}
```

- 위 코드의 로그가 어떨지 물어본다면 보통 `0,1,2`로 찍힐 것이라고 할 것이다.

- 하지만 그렇게 찍히지 않고 모두 3으로 찍힌다. (헉..)

- 이유는 세 개의 함수가 외부 변수 i를 사용하고 있기 때문이다. 두번 째 반복문이 동작할 때 i 의 값은 이미 3이 된다.

- 해결책은 각 루프에 해당 루프 반복에 특정한 새 변수를 생성하는 것이다.

~~~typescript
var funcs = []
// create a bunch of functions
for (var i = 0; i < 3; i++) {
    ;(function() {
        var local = i
        funcs.push(function() {
            console.log(local)
        })
    })()
}
// call them
for (var j = 0; j < 3; j++) {
    funcs[j]()
}
~~~

- 결국 ES6 의 let 을 사용하면 이전 위와 같이 작동할 것이다.

~~~
    								그러므로 let 을 사용하자
~~~



























